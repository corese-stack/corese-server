#prefix ft:  <http://ns.inria.fr/sparql-template/format/map/>
prefix ft:  <file:///user/corby/home/AAServer/data/format/map/>
prefix map: <http://ns.inria.fr/map/>
prefix db:  <http://dbpedia.org/ontology/> .

@public {

function us:number(list) {
    letdyn (num = 0) {
        maplist (function(elem) { 
            xt:cons(xt:first(elem), xt:cons(set (num = num + 1), xt:rest(elem))) }, 
            list)
    }
}

function us:format(elem) {
    let ((?img ?num ?label ?com ?doc ?umap ?lat ?lon) = elem) {
        st:format(ft:cell.html, ?img, ?num, ?label, ?com, ?doc, ?umap, ?lat, ?lon)
    }
}

function us:docTitle(doc) {
    if (strlen(doc) > 40, 
        concat(substr(doc, 1, 40), "..."), 
        doc)
}

function us:selectDepartmentSchema() {
    let (select (aggregate(?label) as ?list) 
        where { ?x a db:Department ; rdfs:label ?label } 
        order by ?label ) {
        xt:sort(?list)
    }
}

function us:selectCommune() {
    let (select (aggregate(distinct ?label) as ?list) 
        where {
            service <store:mapdatamanager> {
                ?url map:commune ?label 
            }}) {
        xt:sort(?list)
    }
}

function us:selectDepartment() {
    let (select (aggregate(distinct ?label) as ?list) 
        where {
            service <store:mapdatamanager> {
                ?url map:departement ?dep .
                ?dept db:inseeCode ?dep ; 
                    rdfs:label ?label 
            }}) {
        xt:sort(?list)
    }
}

function us:selectLocalisation() {
    let (select (aggregate(distinct ?loc) as ?list) 
        where {
            service <store:mapdatamanager> {
                ?url map:localisation/rdfs:subClassOf* ?loc .
            }}) {
        xt:sort(?list)
    }
}

function us:selectLabel() {
    us:selectLabel(map:Objet)
}

function us:selectLabelArtefact() {
    us:selectLabel(map:Artefact)
}

function us:selectLabelNature() {
    us:selectLabel(map:Nature)
}

function us:selectLabel(aclass) {
    let (select aclass (aggregate(distinct ?label) as ?list) 
        where {
            service <store:mapdatamanager> {
                ?url rdf:type/rdfs:subClassOf* aclass ; rdfs:label ?label .
            }}) {
        xt:sort(?list)
    }
}

function us:selectTypeNature() {
    us:selectType(map:Nature)
}

function us:selectTypeArtefact() {
    us:selectType(map:Artefact)
}

function us:selectType(aclass) {
    let (select ?aclass (aggregate(distinct ?url) as ?list) 
        where {
            service <store:mapdatamanager> {
                ?url rdfs:subClassOf* ?aclass .
                ?x rdf:type/rdfs:subClassOf*  ?url
            }}) {
        xt:sort(xt:add(?list, map:Undefined))
    }
}

function us:selectRegion() {
    let (select (aggregate(?label) as ?list) 
        where { ?x a db:Region ; rdfs:label ?label } 
        order by ?label ) {
        xt:sort(?list)
    }
}


function us:instanceofAny(?typeList) {
    let (select ?typeList (aggregate(distinct ?url) as ?list)
         where { 
                values ?typeList {undef}
                values ?type { unnest(?typeList) }
                ?url rdf:type/rdfs:subClassOf* ?type  
            }) {
        return(?list)
    }
}


function us:instanceofEvery(?typeList) {
    let (select ?typeList (aggregate(distinct ?url) as ?list)
         where {
            service <store:mapdatamanager> {
                values ?typeList {undef}
                bind (xt:get(?typeList, 0) as ?fstType)
                ?url rdf:type/rdfs:subClassOf* ?fstType
                
                filter not exists {
                    values ?typeList {undef}
                    values ?type { unnest(?typeList) }
                    filter not exists {?url rdf:type/rdfs:subClassOf* ?type}  
                }
            }}) {
        return(?list)
    }
}

# member of the list or list contains only empty string ""
function us:match(elem, alist) {
    if (mapany (function(x) {strlen(x)>0}, alist)) {
        xt:member(elem, alist)
    }
    else {
        return(true)
    }
}

function us:sublist(alist, start, end) {
    let (res = xt:list()) {
        for (index in xt:iota(start, end)) {
            xt:add(res, xt:get(alist, index))
        } ;
        return (res)
    }
}

# rewrite boolean type list into conjunctive normal form
# A union B and C -> (A or B) and C
# A or B and C    -> A or (B and C)
# split or -> ((A) (B C))
# split and : A union B and C -> ((A B) (C))
# distrib  -> AC or BC

function us:process(alist) {
    us:process(alist, map:Objet)
}

# root is used in case of not A
# rewritten as: root and not A
function us:process(alist, root) {
    xt:print("input:", alist);
    # rewrite <AND_NOT> as <AND> <NOT> ; remove map:Undefined
    let (tmp = us:preprocess(alist),
         res0 = us:mysplit(tmp, <OR>),
         res1 = maplist(function(part) { us:mysplit(part, <AND>) }, res0),
         # res2 = list ((A union B) and (C)) -- with no explicit and
         res2 = maplist(function(part) { maplist(us:cleanUnion, part) }, res1),
         # res3 = list ((A C) (B C))
         res3 = maplist(us:distrib, res2),
         res4 = reduce(xt:append, res3),
         res5 = us:postprocess(res4, root))
         {
         xt:print("rewrite:", res5);
         return (res5)
    }
}

# OPER_NOT -> OPER NOT
function us:preprocess(alist) {
    letdyn (res = xt:list(), amap = xt:map()) {
        xt:set(amap, <AND_NOT>, <AND>);
        xt:set(amap, <OR_NOT>, <OR>);
        xt:set(amap, <UNION_NOT>, <UNION>);
        
        map (function(elem) { 
           if  (elem = map:Undefined) {
            # skip
           } 
           else if (xt:has(amap, elem)) {
              xt:add(res, xt:get(amap, elem));
              xt:add(res, <NOT>);
           } 
           else {
            xt:add(res, elem)
           }}, alist) ;
        return (res)
    }
}

# ((<NOT> A) B) -> (map:Object (<NOT> A) B)
function us:postprocess(alist, root) {
    map (function(exp) { if (xt:size(exp) >= 1 && ! isURI(xt:first(exp))) { xt:add(exp, 0, root) } } , alist);
    return (alist)
}


# parse and split oper
# rewrite NOT X as (NOT X)
function us:mysplit(alist, oper) {
    let (tmp = xt:list(), res = xt:list(), anot = false) {
        for (elem in alist) {
            if (elem = oper) {
                set (anot = false);
                if (xt:size(tmp)>0) {
                    xt:add(res, tmp);
                } ;
                set(tmp = xt:list())
            }
            else if (elem = <NOT>) {
                set(anot = true);
            }
            else if (elem in (<AND>, <OR>, <UNION>)) {
                    xt:add(tmp, elem);
                    set (anot = false);
            }
            else if (anot) {
                    xt:add(tmp, xt:list(<NOT>, elem));
                    set (anot = false);
            }
            else {
                    xt:add (tmp, elem)
            }
            
        } ;
        if (xt:size(tmp)>0) {
            xt:add(res, tmp); 
        };
        return (res)
    }
}

function us:cleanUnion(alist) {
    us:clean(alist, <UNION>)
}

function us:clean(alist, elem) {
    if (xt:member(elem, alist), us:clean(xt:remove(alist, elem), elem), alist)
}

# ((A B) (C)) -> ((A C) (B C))
function us:distrib(alist) {
    if (xt:size(alist) = 0) {
        return (alist)
    }
    else if (xt:size(alist) = 1) {
        return (maplist (xt:list, xt:first(alist)))
    }
    else {
        letdyn ((fst | rst) = alist) {
            let (res =
            maplist (function(elem) { 
                letdyn (myelem = elem, distrib = us:distrib(rst)) {
                    maplist (function(sub) { xt:cons(myelem, sub) }, distrib)
                }
            }, fst)) {
            
            return (reduce(xt:append, res));
            }
        }
    }
}


# alist = ((name select title format index repeat))
# when repeat > 1, repeat ith and i+1th select n times
# see myweb.rul template st:selecttable

function us:expand (alist) {
    letdyn (res = xt:list(), skip = false, num = 0, mylist = alist) {
        map (function(elem) {
            let ((name aselect title aformat index repeat myname myvalue) = elem) {
                if (skip) {
                    set(skip = false)
                }
                else if (repeat <= 1) {
                    xt:add(res, elem);
                }
                else {
                    set (skip = true);
                    let ((name2 aselect2 title2 format2 index2 repeat2 myname2 myvalue2) = xt:get(mylist, num+1)) {
                        for (i in xt:iota(0, repeat - 1)) {
                            xt:add(res, xt:list(name, aselect, title,    aformat, index  + 2*i, repeat, myname, myvalue));
                            xt:add(res, xt:list(name2, aselect2, title2, format2, index2 + 2*i, repeat2, myname2, myvalue2))
                        }
                    }
                } ;
                set (num = num + 1)
            }
        },
        alist);
        
        return (res)
    } 
}

# alist = (key val key val)
# extract key=val ; set context(key, list(val))

function us:extract(alist) {
     let (keyList = @("departement" "region" "commune" "label")) {
        us:extract(alist, keyList)
     }   
}

function us:extract(alist, keyList) {
    let (res = xt:list(), key = "") {
        for (value in alist) {
            if (xt:member(value, keyList)) {
                if (xt:size(res) > 0) {
                    st:set(key, res);
                } ;
                set (key = value) ;
                set (res = xt:list())
            }
            else {
                xt:add(res, value)
            }
        } ;
        if (xt:size(res) > 0) {
            st:set(key, res);
        }
    } 
}


}
